<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaun Clarence Raj | AI & Machine Learning Engineer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* All your existing CSS stays here */
        
        /* ... */
        
        /* ADD THIS NEW CSS AT THE END OF YOUR STYLE SECTION */
        
        /* Fix for animation reveal */
        .card, .about-content, .about-image, .contact-container {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .card.animate, .about-content.animate, .about-image.animate, .contact-container.animate {
            opacity: 1;
            transform: translateY(0);
        }

        /* Performance optimizations */
        .hero-content, .hero-image, .shape, .card, .about-image, .contact-container {
            will-change: transform;
        }

        /* Fix for mobile menu */
        .nav-links {
            z-index: 1000;
        }

        .close-menu {
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .nav-links.active .close-menu {
            opacity: 1;
            pointer-events: auto;
        }

        /* Fix for shapes to ensure they don't cause layout issues */
        .floating-shapes {
            pointer-events: none;
            overflow: hidden;
        }

        /* Fix for card transitions */
        .card {
            transform-style: preserve-3d;
            transition: transform 0.5s ease, box-shadow 0.5s ease, border-left 0.3s ease;
        }

        /* Ensure proper stacking context for 3D transforms */
        .hero, .about-section, .contact-section {
            transform-style: preserve-3d;
            isolation: isolate;
        }

        /* Fix for scroll indicator to ensure it's always visible */
        .scroll-indicator {
            z-index: 10;
            background: rgba(15, 15, 26, 0.5);
            padding: 10px;
            border-radius: 20px;
        }
        /* END OF NEW CSS */
    </style>
</head>
<body>
    <!-- All your HTML content stays the same -->
    
    <!-- ... -->
    
    <!-- REPLACE YOUR ENTIRE SCRIPT SECTION WITH THIS -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ===== ELEMENT REFERENCES =====
            const navbar = document.getElementById('navbar');
            const cards = document.querySelectorAll('.card');
            const heroContent = document.querySelector('.hero-content');
            const heroImage = document.querySelector('.hero-image');
            const logo = document.querySelector('.logo');
            const aboutImage = document.querySelector('.about-image');
            const contactContainer = document.querySelector('.contact-container');
            const menuToggle = document.getElementById('menuToggle');
            const navLinks = document.getElementById('navLinks');
            const closeMenu = document.getElementById('closeMenu');
            const scrollIndicator = document.getElementById('scrollIndicator');
            const shapes = document.querySelectorAll('.shape');
            
            // ===== ANIMATION STATE =====
            // Store animation state separately to avoid transform conflicts
            const state = {
                scroll: {
                    y: 0,
                    lastPosition: 0
                },
                mouse: {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2,
                    lastMoveTime: 0
                },
                elements: {
                    heroContent: { translateX: 0, translateY: 0, translateZ: 0 },
                    heroImage: { translateX: 0, translateY: -50, translateZ: 30 },
                    aboutImage: { translateX: 0, translateY: 0, rotateY: 0, translateZ: 0 },
                    logo: { translateZ: 0 },
                    contactContainer: { translateZ: 0 },
                    shapes: Array.from(shapes).map(() => ({ 
                        translateX: 0, translateY: 0, translateZ: 0, rotate: 0 
                    }))
                },
                rendering: {
                    updatePending: false
                }
            };

            // ===== PAGE SETUP =====
            // Set page title
            document.title = "Shaun Clarence Raj | AI & Machine Learning Engineer";
            
            // ===== EVENT HANDLERS =====
            // Scroll indicator click
            scrollIndicator.addEventListener('click', () => {
                document.getElementById('experience').scrollIntoView({ behavior: 'smooth' });
            });
            
            // Mobile menu toggle
            menuToggle.addEventListener('click', () => {
                navLinks.classList.add('active');
                document.body.style.overflow = 'hidden';
            });
            
            closeMenu.addEventListener('click', () => {
                navLinks.classList.remove('active');
                document.body.style.overflow = 'auto';
            });
            
            // Smooth scrolling for all anchor links
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Close mobile menu if open
                    if (navLinks.classList.contains('active')) {
                        navLinks.classList.remove('active');
                        document.body.style.overflow = 'auto';
                    }
                    
                    const targetId = this.getAttribute('href');
                    const targetElement = document.querySelector(targetId);
                    
                    if (targetElement) {
                        targetElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });

            // ===== 3D CARD EFFECT =====
            cards.forEach(card => {
                // Store initial box-shadow for resetting
                const initialBoxShadow = '0 10px 30px rgba(0, 0, 0, 0.1)';
                
                card.addEventListener('mousemove', e => {
                    const rect = card.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const xRotation = ((y - rect.height / 2) / 15) * -1;
                    const yRotation = (x - rect.width / 2) / 15;
                    
                    // Apply transform directly for card hover effect (doesn't conflict with other animations)
                    card.style.transform = `
                        perspective(1000px)
                        rotateX(${xRotation}deg)
                        rotateY(${yRotation}deg)
                        translateZ(30px)
                    `;
                    
                    // Dynamic shadow
                    const shadowX = (x - rect.width / 2) / 25;
                    const shadowY = (y - rect.height / 2) / 25;
                    card.style.boxShadow = `
                        ${shadowX}px ${shadowY}px 30px rgba(106, 0, 255, 0.2),
                        0 10px 20px rgba(0, 0, 0, 0.1)
                    `;
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) translateZ(0)';
                    card.style.boxShadow = initialBoxShadow;
                });
            });

            // ===== SCROLL HANDLER =====
            // Properly throttled scroll handler
            window.addEventListener('scroll', () => {
                state.scroll.y = window.scrollY;
                
                // Navbar change on scroll (direct style change, no conflict)
                if (window.scrollY > 50) {
                    navbar.classList.add('scrolled');
                } else {
                    navbar.classList.remove('scrolled');
                }
                
                // Update scroll-dependent animations
                updateScrollAnimations();
                
                // Request render frame
                requestRender();
            });

            function updateScrollAnimations() {
                // Update element transforms based on scroll position
                if (heroContent) {
                    state.elements.heroContent.translateY = state.scroll.y * 0.2;
                }
                
                if (logo) {
                    state.elements.logo.translateZ = state.scroll.y * 0.03;
                }
                
                if (aboutImage) {
                    state.elements.aboutImage.translateZ = state.scroll.y * 0.02;
                    state.elements.aboutImage.rotateY = state.scroll.y * 0.01;
                }
                
                if (contactContainer) {
                    state.elements.contactContainer.translateZ = state.scroll.y * 0.01;
                }
                
                // Update shapes with different speeds
                shapes.forEach((shape, index) => {
                    const speed = 0.05 + (index * 0.01);
                    state.elements.shapes[index].translateY = state.scroll.y * speed;
                    state.elements.shapes[index].translateZ = 50 + (index * 10);
                });
            }

            // ===== MOUSE MOVE HANDLER =====
            // Properly throttled mousemove handler
            document.addEventListener('mousemove', e => {
                const now = Date.now();
                
                // Throttle to 30fps (33ms)
                if (now - state.mouse.lastMoveTime > 33) {
                    state.mouse.x = e.clientX;
                    state.mouse.y = e.clientY;
                    state.mouse.lastMoveTime = now;
                    
                    // Update mouse-dependent animations
                    updateMouseAnimations();
                    
                    // Request render frame
                    requestRender();
                }
            });

            function updateMouseAnimations() {
                // Move hero content in opposite direction of mouse
                if (heroContent) {
                    const heroRect = heroContent.getBoundingClientRect();
                    const heroX = (heroRect.left + heroRect.width / 2 - state.mouse.x) / 30;
                    const heroY = (heroRect.top + heroRect.height / 2 - state.mouse.y) / 30;
                    
                    state.elements.heroContent.translateX = heroX;
                    // Note: Y position from mouse movement is combined with scroll position
                }
                
                // Move hero image in direction of mouse (parallax effect)
                if (heroImage) {
                    const imgRect = heroImage.getBoundingClientRect();
                    const imgX = (state.mouse.x - (imgRect.left + imgRect.width / 2)) / 40;
                    const imgY = (state.mouse.y - (imgRect.top + imgRect.height / 2)) / 40;
                    
                    state.elements.heroImage.translateX = imgX;
                    state.elements.heroImage.translateY = -50 + imgY; // -50% is the base position
                }
                
                // Move about image
                if (aboutImage) {
                    const aboutRect = aboutImage.getBoundingClientRect();
                    const aboutX = (state.mouse.x - (aboutRect.left + aboutRect.width / 2)) / 50;
                    const aboutY = (state.mouse.y - (aboutRect.top + aboutRect.height / 2)) / 50;
                    
                    state.elements.aboutImage.translateX = aboutX;
                    state.elements.aboutImage.translateY = aboutY;
                    state.elements.aboutImage.rotateY = aboutX * 0.5;
                }
                
                // Move floating shapes
                shapes.forEach((shape, index) => {
                    const shapeRect = shape.getBoundingClientRect();
                    const shapeX = (state.mouse.x - (shapeRect.left + shapeRect.width / 2)) / (100 + index * 10);
                    const shapeY = (state.mouse.y - (shapeRect.top + shapeRect.height / 2)) / (100 + index * 10);
                    
                    state.elements.shapes[index].translateX = shapeX;
                    // Note: Y position from mouse movement is combined with scroll position
                });
            }

            // ===== RENDERING =====
            // Consolidated render function to apply all transforms
            function requestRender() {
                if (!state.rendering.updatePending) {
                    state.rendering.updatePending = true;
                    requestAnimationFrame(renderAllElements);
                }
            }

            function renderAllElements() {
                // Apply all transforms at once
                
                // Hero content
                if (heroContent) {
                    const { translateX, translateY, translateZ } = state.elements.heroContent;
                    heroContent.style.transform = `translateX(${translateX}px) translateY(${translateY}px) translateZ(${translateZ}px)`;
                }
                
                // Hero image
                if (heroImage) {
                    const { translateX, translateY, translateZ } = state.elements.heroImage;
                    heroImage.style.transform = `translateX(${translateX}px) translateY(${translateY}%) translateZ(${translateZ}px)`;
                }
                
                // About image
                if (aboutImage) {
                    const { translateX, translateY, translateZ, rotateY } = state.elements.aboutImage;
                    aboutImage.style.transform = `translateX(${translateX}px) translateY(${translateY}px) translateZ(${translateZ}px) rotateY(${rotateY}deg)`;
                }
                
                // Logo
                if (logo) {
                    const { translateZ } = state.elements.logo;
                    logo.style.transform = `translateZ(${translateZ}px)`;
                }
                
                // Contact container
                if (contactContainer) {
                    const { translateZ } = state.elements.contactContainer;
                    contactContainer.style.transform = `translateZ(${translateZ}px)`;
                }
                
                // Shapes
                shapes.forEach((shape, index) => {
                    const { translateX, translateY, translateZ, rotate } = state.elements.shapes[index];
                    shape.style.transform = `translateX(${translateX}px) translateY(${translateY}px) translateZ(${translateZ}px) rotate(${rotate}deg)`;
                });
                
                state.rendering.updatePending = false;
            }

            // ===== REVEAL ANIMATIONS =====
            // Intersection Observer for reveal animations
            const revealElements = document.querySelectorAll('.card, .about-content, .about-image, .contact-container');
            
            const revealObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('animate');
                        // Stop observing once animated
                        revealObserver.unobserve(entry.target);
                    }
                });
            }, {
                threshold: 0.1,
                rootMargin: '0px 0px -100px 0px' // Trigger animation a bit before the element comes into view
            });
            
            revealElements.forEach(element => {
                revealObserver.observe(element);
            });

            // Initial render to set everything up
            updateScrollAnimations();
            updateMouseAnimations();
            renderAllElements();
        });
    </script>
    <!-- END OF SCRIPT REPLACEMENT -->
</body>
</html>